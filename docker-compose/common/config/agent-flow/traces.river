// https://github.com/grafana/agent-configurator

logging {
	level  = "warn"
	format = "logfmt"
}

tracing {
	sampling_fraction = 0.8
	write_to          = [otelcol.processor.batch.containers.input]
}

module.file "docker_compose" {
	filename = env("AGENT_CONFIG_FOLDER") + "/modules/docker_compose.river"

	arguments {
		metrics_endpoint = "http://gateway:8080"
		traces_endpoint  = "gateway:4317"
	}
}

discovery.docker "containers" {
	host = "unix:///var/run/docker.sock"

	filter {
		name   = "status"
		values = ["running"]
	}
}

discovery.relabel "containers" {
	targets = discovery.docker.containers.targets

	// filter by service name
	rule {
		source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
		action        = "keep"
		regex         = "(agent|mimir|grafana|loki|loki-.*|tempo|pyroscope)"
	}

	rule {
		source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
		regex         = "(.*)"
		replacement   = "monitoring-system/$1"
		target_label  = "job"
	}

	rule {
		source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
		regex         = "(.*)"
		target_label  = "pod"
	}

	rule {
		source_labels = ["__meta_docker_container_label_com_docker_compose_service"]
		regex         = "(.*)"
		target_label  = "app"
	}

	rule {
		source_labels = ["__meta_docker_container_name"]
		regex         = "/(.*)"
		target_label  = "container"
	}
}

/********************************************
 * Metrics
 ********************************************/

prometheus.exporter.unix "containers" {
	set_collectors     = ["cpu"]
	disable_collectors = ["diskstats", "mdadm", "textfile", "hwmon"]
}

prometheus.scrape "integrations" {
	targets = concat(
		prometheus.exporter.unix.containers.targets,
	)
	scrape_interval = "15s"

	enable_protobuf_negotiation = true
	scrape_classic_histograms   = true

	clustering {
		enabled = true
	}

	forward_to = [prometheus.relabel.integrations.receiver]
}

prometheus.scrape "containers" {
	targets         = discovery.relabel.containers.output
	scrape_interval = "15s"

	enable_protobuf_negotiation = true
	scrape_classic_histograms   = true

	clustering {
		enabled = true
	}

	forward_to = [module.file.docker_compose.exports.metrics_receiver]
}

prometheus.scrape "minio" {
	targets = [{"__address__" = "minio:9000", "job" = "minio-job"}]

	scrape_interval = "15s"

	enable_protobuf_negotiation = true
	scrape_classic_histograms   = true

	clustering {
		enabled = true
	}
	metrics_path = "/minio/v2/metrics/cluster"

	forward_to = [prometheus.relabel.integrations.receiver]
}

prometheus.relabel "integrations" {
	rule {
		source_labels = ["job"]
		regex         = "(integrations|monitoring-system)/(.*)"
		target_label  = "pod"
		replacement   = "${2}"
	}

	rule {
		source_labels = ["job"]
		regex         = "(integrations|monitoring-system)/(.*)"
		target_label  = "container"
		replacement   = "${2}"
	}

	forward_to = [module.file.docker_compose.exports.metrics_receiver]
}

/********************************************
 * Jaeger for Traces Metrics
 ********************************************/

otelcol.receiver.jaeger "containers" {
	protocols {
		grpc {
			endpoint = "0.0.0.0:14250"
		}

		thrift_http {
			endpoint = "0.0.0.0:14268"
		}

		thrift_binary {
			endpoint = "0.0.0.0:6832"
		}

		thrift_compact {
			endpoint = "0.0.0.0:6831"
		}
	}

	output {
		metrics = [otelcol.processor.transform.add_metric_datapoint_attributes.input]
		traces  = [otelcol.processor.resourcedetection.containers.input]
	}
}

/********************************************
 * Otelcol for Traces Metrics
 ********************************************/

otelcol.receiver.otlp "containers" {
	grpc {
		endpoint = "0.0.0.0:4317"
	}

	http {
		endpoint = "0.0.0.0:4318"
	}

	output {
		metrics = [otelcol.processor.transform.add_metric_datapoint_attributes.input]
		traces  = [otelcol.processor.resourcedetection.containers.input]
	}
}

otelcol.processor.resourcedetection "containers" {
	detectors = ["env"]

	output {
		metrics = [otelcol.processor.attributes.containers.input]
		traces  = [otelcol.processor.attributes.containers.input]
	}
}

otelcol.processor.transform "add_metric_datapoint_attributes" {
	error_mode = "ignore"

	metric_statements {
		context    = "datapoint"
		statements = [
			`set(attributes["deployment.environment"], resource.attributes["deployment.environment"])`,
			`set(attributes["service.version"], resource.attributes["service.version"])`,
		]
	}

	output {
		metrics = [otelcol.processor.attributes.containers.input]
	}
}

otelcol.processor.attributes "containers" {
	// Inserts a new attribute "cluster" to spans where the key doesn't exist.
	action {
		key    = "cluster"
		value  = "docker-compose"
		action = "insert"
	}

	output {
		metrics = [otelcol.processor.transform.add_resource_attributes.input]
		traces  = [otelcol.processor.transform.add_resource_attributes.input]
	}
}

otelcol.processor.transform "add_resource_attributes" {
	error_mode = "ignore"

	metric_statements {
		context    = "resource"
		statements = [
			`set(attributes["cluster"], "docker-compose") where attributes["cluster"] == nil`,
		]
	}

	trace_statements {
		context    = "resource"
		statements = [
			`set(attributes["cluster"], "docker-compose") where attributes["cluster"] == nil`,
		]
	}

	output {
		metrics = [otelcol.processor.filter.containers.input]
		traces  = [otelcol.processor.filter.containers.input]
	}
}

otelcol.processor.filter "containers" {
	error_mode = "ignore"

	output {
		metrics = [otelcol.processor.batch.containers.input]
		traces  = [otelcol.processor.batch.containers.input]
	}
}

otelcol.processor.batch "containers" {
	send_batch_size     = 16384
	send_batch_max_size = 0
	timeout             = "2s"

	output {
		metrics = [otelcol.processor.memory_limiter.containers.input]
		traces  = [otelcol.processor.memory_limiter.containers.input]
	}
}

otelcol.processor.memory_limiter "containers" {
	check_interval         = "1s"
	limit_percentage       = 50
	spike_limit_percentage = 30

	output {
		metrics = [otelcol.exporter.prometheus.containers.input]
		traces  = [module.file.docker_compose.exports.traces_receiver]
	}
}

otelcol.exporter.prometheus "containers" {
	forward_to = [module.file.docker_compose.exports.metrics_receiver]
}
