/*
Module: traces
*/
argument "traces_forward_to" {
	optional = false
}

argument "logs_forward_to" {
	optional = false
}

argument "metrics_forward_to" {
	optional = false
}

argument "cluster" {
	optional = true
	default  = "k3d-k3s-codelab"
}

argument "otlp_http_endpoint" {
	optional = true
	default  = "0.0.0.0:4318"
}

argument "otlp_grpc_endpoint" {
	optional = true
	default  = "0.0.0.0:4317"
}

/********************************************
 * Jaeger for Metrics Logs Traces
 ********************************************/

otelcol.receiver.jaeger "default" {
	protocols {
		grpc {
			endpoint = "0.0.0.0:14250"
		}

		thrift_http {
			endpoint = "0.0.0.0:14268"
		}

		thrift_binary {
			endpoint = "0.0.0.0:6832"
		}

		thrift_compact {
			endpoint = "0.0.0.0:6831"
		}
	}

	output {
		metrics = [otelcol.processor.batch.default.input]
		logs    = [otelcol.processor.batch.default.input]
		traces  = [otelcol.processor.batch.default.input]
	}
}

/********************************************
 * Otelcol for Metrics Logs Traces
 ********************************************/
// https://grafana.com/docs/agent/latest/flow/reference/components/otelcol.receiver.otlp/
otelcol.receiver.otlp "default" {
	grpc {
		endpoint = argument.otlp_grpc_endpoint.value
	}

	http {
		endpoint = argument.otlp_http_endpoint.value
	}

	output {
		metrics = [otelcol.processor.batch.default.input]
		logs    = [otelcol.processor.batch.default.input]
		traces  = [
			otelcol.processor.batch.default.input,
			otelcol.connector.spanlogs.autologging.input,
		]
	}
}

otelcol.processor.batch "default" {
	send_batch_size     = 16384
	send_batch_max_size = 0
	timeout             = "2s"

	output {
		metrics = [otelcol.processor.memory_limiter.default.input]
		logs    = [otelcol.processor.memory_limiter.default.input]
		traces  = [otelcol.processor.memory_limiter.default.input]
	}
}

// The OpenTelemetry spanlog connector processes incoming trace spans and extracts data from them ready
// for logging.
otelcol.connector.spanlogs "autologging" {
	// We only want to output a line for each root span (ie. every single trace), and not for every
	// process or span (outputting a line for every span would be extremely verbose).
	spans     = false
	roots     = true
	processes = false

	// We want to ensure that the following three span attributes are included in the log line, if present.
	span_attributes = [
		"http.method",
		"http.target",
		"http.status_code",
	]

	// Overrides the default key in the log line to be `traceId`, which is then used by Grafana to
	// identify the trace ID for correlation with the Tempo datasource.
	overrides {
		trace_id_key = "traceId"
	}

	// Send to the OpenTelemetry Loki exporter.
	output {
		logs = [otelcol.exporter.loki.autologging.input]
	}
}

// Simply forwards the incoming OpenTelemetry log format out as a Loki log.
// We need this stage to ensure we can then process the logline as a Loki object.
otelcol.exporter.loki "autologging" {
	forward_to = [loki.process.autologging.receiver]
}

// The Loki processor allows us to accept a correctly formatted Loki log and mutate it into
// a set of fields for output.
loki.process "autologging" {
	// The JSON stage simply extracts the `body` (the actual logline) from the Loki log, ignoring
	// all other fields.
	stage.json {
		expressions = {"body" = ""}
	}
	// The output stage takes the body (the main logline) and uses this as the source for the output
	// logline. In this case, it essentially turns it into logfmt.
	stage.output {
		source = "body"
	}

	forward_to = argument.logs_forward_to.value
}

otelcol.processor.memory_limiter "default" {
	check_interval = "1s"

	// limit = "150MiB" // alternatively, set `limit_percentage` and `spike_limit_percentage`
	limit_percentage       = 50
	spike_limit_percentage = 30

	output {
		metrics = [otelcol.processor.k8sattributes.default.input]
		logs    = [otelcol.processor.k8sattributes.default.input]
		traces  = [otelcol.processor.k8sattributes.default.input]
	}
}

otelcol.processor.k8sattributes "default" {
	output {
		metrics = [otelcol.processor.resourcedetection.default.input]
		logs    = [otelcol.processor.resourcedetection.default.input]
		traces  = [otelcol.processor.resourcedetection.default.input]
	}
}

otelcol.processor.resourcedetection "default" {
	// If you set up a OTEL_RESOURCE_ATTRIBUTES environment variable with value of TestKey=TestValue
	// then all logs, metrics, and traces have a resource attribute with a key TestKey and value of TestValue.
	detectors = ["env"]

	output {
		metrics = [otelcol.exporter.prometheus.tracesmetrics.input]
		logs    = [otelcol.exporter.loki.traceslogs.input]
		traces  = argument.traces_forward_to.value
	}
}

otelcol.exporter.prometheus "tracesmetrics" {
	forward_to = argument.metrics_forward_to.value
}

otelcol.exporter.loki "traceslogs" {
	forward_to = [loki.process.traceslogs.receiver]
}

loki.process "traceslogs" {
	stage.drop {
		longer_than = "8KB"
		older_than  = "12h"
	}

	stage.tenant {
		value = "fake"
	}

	forward_to = argument.logs_forward_to.value
}
